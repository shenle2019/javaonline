# Java-web学习笔记008

### 加解密

- 摘要

摘要算法(hash算法, 散列算法)
一种能产生特殊输出的算法
给定任意长度的文本, 生成定长的文本(摘要)

特点就不可逆
就是给你一段摘要, 不可能还原出原数据

通过摘要来检查原文是否被篡改
这就是摘要的用途

摘要有个问题
就是有可能一段摘要对应两个不同的原文
这就是碰撞

12345 生成的摘要是 15
5431 生成的摘要也是 15
这就是碰撞

md5 和 sha1
MD5, 128 位的数字, 16字节
sha1, 160 位, 20 字节
md5 90年代就已经不安全了, 弄出了 sha1
sha1 不安全了, 搞了一个 sha256, 256 位

1. 校验文件是否被篡改
2. 保护密码. 网站不明文存用户密码, 而是存摘要算法算的摘要

加盐
盐就是我们自己找的一个随机字符串
存用户密码的时候, 把密码和随机字符串相加, 再算摘要

彩虹表
存了原文和摘要值的对应关系
这些原文都是简单的原文


摘要不等于随机字符串

http://xxx.com/reset_passworld?token=sdfsdfefwe333

sdfsdfefwe333 这段是随机字符串

v2ex, 用 unixtime + MD5 来生成 token



- 补充：

摘要是一种算法的总称, 使用这种算法对原始数据进行运算后生成字符串.不同的原始数据理论上计算的结果是不同的.即给定任意长度的文本, 生成定长的文本
这样达到的效果是针对原始数据生成其独一无二的'指纹'.通过对比数据的'指纹'可以识别数据的真伪.摘要算法是不可逆的, 即使拿到了这个指纹, 也无法利用这个指纹恢复出原始数据.因此安全性有一定的保障.

常见的摘要算法有md5, sha1, sha256等.md5和sha1现在已经不是安全的摘要算法了.

在保存用户的密码时,常用的方法是使用摘要算法生成用户密码原始数据的摘要,在服务器数据库里面只保存这个摘要而不是用户的原始密码.这样做的好处是即使数据库被黑客攻破, 被盗的也只是用户的密码的摘要而不是原始密码.安全性有一定的提高.
可即便是这样做, 安全性的提高也是有限的, 因为很多用户使用的是简单密码.而这些简单密码的"指纹"早已被计算出来并生成了一个"指纹库", 即彩虹表.如果用户使用了简单的密码, 如生日/单词等, 黑客可以通过比对, 轻易地获得用户的原始密码.
为了解决这个问题, 进一步提高安全性, "加盐"的操作被应用在用户密码保存上.



- 加密
  对称加密
  非对称加密

加密
加密和摘要的区别
加密的内容可以还原成原文, 摘要不可以还原成原文

加密有两种

1. 对称加密. 用同一个秘钥(yue, 第四声), 加密和还原

2. 非对称秘钥. 有两个秘钥, 一个叫公钥, 一个叫私钥.
   公钥加密的, 私钥可以解密.
   私钥加密的, 公钥可以解密.

   

   - 补充：

     1.A要向B发送信息，A和B都要产生一对密码用于加密
     2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。
     3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。
     4.A将这个消息发给B（已经用B的公钥加密消息）。
     5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。

     非对称加密算法需要两个密钥：公开密钥和私有密钥。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法
     所谓非对称加密，就是指该算法需要一对密钥，使用其中一个（公钥）加密，则需要用另一个（私钥）才能解密。

     另外:加密的内容可以还原成原文, 摘要不可以还原成原文;

   

- https

https
就是把所有传输内容都加密的东西
只是把 http 的内容加密传输


1. 你访问服务器的时候, 服务器会把它的公钥给你
2. 你收到了公钥之后, 把一个叫对话秘钥的东西用公钥加密, 对话秘钥就是一把对称加密的秘钥
3. 服务器收到密文之后, 用自己的私钥来解密, 得到对话公钥
4. 之后所有的交流内容, 都用对话公钥来加密

怎么知道收到的公钥是服务器的公钥.

```
HTTP + 加密 + 认证 + 完整性保护 = HTTPS

由于公开密钥加密的速度要比共享密钥的速度慢很多，所以应该使用两者的优势，采用混合加密方式：在交换密钥环节使用公开密钥加密方式，之后建立通信交换报文阶段则使用共享密钥加密方式。

公开密钥加密方式还存在一些问题，就是无法证明公开密钥本身就是真的公钥，应为在公钥传输过程中，可能已经被攻击者换掉。
为了解决上述问题，可以使用有数字证书认证机构（CA）和其相关机关颁发的公开密钥证书。具体流程如下：
		○ 1.服务器运营人员向第三方数字证书认证机构购买由自己的信息签名的公开密钥，并将公开密钥放入公钥证书后绑定在一起，公钥证书也叫数字证书或证书
		○ 2.服务器将公钥证书发送给客户端，以进行公开密钥加密方式。
		○ 3.接到证书的客户端可使用数字证书认证机构的公开密钥，对服务器发来的证书上的数字签名进行验证，一旦验证通过，客户端可以明确两件事：
一，认证服务器的公开密钥的真实有效的数字证书认证机构。二，服务器的公开密钥是值的信赖的。
上面的第三步中，客户端的数字证书认证机构的公开密钥是怎么来的呢？
如果使用通信的方式，如何安全的转交是一件很困难的事，因此多数浏览器都已经内置了常用认证机关的公开密钥，手机端也是如此。

https通信机制:
验证服务器端
允许客户端和服务器端选择加密算法和密码，确保双方都支持
验证客户端(可选)
使用公钥加密技术来生成共享加密数据
创建一个加密的 SSL 连接
基于该 SSL 连接传递 HTTP 请求

上面讲了加密 + 认证，还剩下完整性保护。
在https的通信流程中，应用层发送数据时会附加一种叫做MAC（Message Authentication Code）的报文摘要,Mac能够查知报文是否早遭到篡改，从而保护报文的完整性。

附:https
就是把所有传输内容都加密的东西
只是把 http 的内容加密传输

1. 你访问服务器的时候, 服务器会把它的公钥给你
2. 你收到了公钥之后, 把一个叫对话秘钥的东西用公钥加密, 对话秘钥就是一把对称加密的秘钥
3. 服务器收到密文之后, 用自己的私钥来解密, 得到对话公钥
4. 之后所有的交流内容, 都用对话公钥来加密
```



- 证书系统

```
数字证书采用公钥体制，即利用一对互相匹配的密钥进行加密、解密。每个用户自己设定一把特定的仅为本人所知的私有密钥(私钥)，用它进行解密和 签名;
同时设定一把公共密钥(公钥)并由本人公开，为一组用户所共享，用于加密和验证签名。当发送一份保密文件时，发送方使用接收方的公钥对数据加密，
而 接收方则使用自己的私钥解密，这样信息就可以安全无误地到达目的地了。通过数字的手段保证加密过程是一个不可逆过程，即只有用私有密钥才能解密。


数字签名具体做法是:
(1)将报文按双方约定的HASH算法计算得到一个固定位数的报文摘要。在数学上保证:只要改动报文中任何一位，重新计算出的报文摘要值就会与原先的值不相符。这样就保证了报文的不可更改性。
(2)将该报文摘要值用发送者的私人密钥加密，然后连同原报文一起发送给接收者，而产生的报文即称数字签名。
(3)接收方收到数字签名后，用同样的HASH算法对报文计算摘要值，然后与用发送者的公开密钥进行解密解开的报文摘要值相比较。如相等则说明报文确实来自所称的发送者。

CA机构，又称为证书授证(Certificate Authority)中心，作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。
CA中心为每个使用公开密钥的用户发放一个数字证 书，数字证书的作用是证明证书中列出的用户合法拥有证书中列出的公开密钥。
CA机构的数字签名使得攻击者不能伪造和篡改证书。它负责产生、分配并管理所有 参与网上交易的个体所需的数字证书，因此是安全电子交易的核心环节。
由此可见，证书授权(CA)中心是开拓和规范电子商务市场必不可少的一步。为保证用户之间在网上传递信息的安全性、真实性、可靠性、完整性和不可抵 赖性，
不仅需要对用户的身份真实性进行验证，也需要有一个具有权威性、公正性、唯一性的CA机构，负责向电子商务的各个主体颁发并管理符合国内、国际安全 电子交易协议标准的电子商务安全数字证书。
```





- 签名
  我要发一段信息, 我先对信息做一个摘要, 摘要的内容用我的私钥加密, 信息和加密后的摘要一起发出去
  收信的人拥有我的公钥, 收到信息之后, 对加密的摘要做一个解密, 然后他算一遍信息的摘要
  对比自己算出来的摘要和解密后的摘要是否一致
  如果一致, 就能证明这个信息是我发的, 并且没有被篡改


有一公认的权威机构, 会把自己的公钥满世界送, 送给浏览器, 浏览器内置可信的这些机构的公钥
服务器会发一个证书, 这个证书是被权威机构签名的
证书包括了服务器的公钥, 一些乱七八糟的信息, 权威机构给这些东西做的一个签名

最关键的就是浏览器内置的权威机构的证书要是正确的



- 补充对session的理解

```java
1.session 的机制和流程
 浏览器与服务器之间使用http协议通讯，http协议是无状态的协议，问题就出现了：服务器不知道你是谁，你又做了哪些 动作，使用了session之后就可以解决这个问题；但是问题又出现了，服务器又是怎么来表示不同的用户和浏览器呢？在session的工作机制中，会给每个访问者创建一个唯一ID:session_id（类似于居民身份证），服务器会将这个ID返回给客户端浏览器并存储在内存中，也就是cookie，浏览器关闭后会清空这个cookie；
以后浏览器每次请求都会额外加这个参数值，服务器根据这个session_id，就能获得客户端的状态。


2.session 解决的问题

Cookie 可以解决 http 请求无状态的问题
我们可以辨别出几个 http 请求都是同一个用户发的
但是, 我们没有解决伪造的问题
我让 cookie 存一个无意义的字符串
然后我的服务器上存一个 HashMap, 存了哪个无意义的字符串(一个随机的字符串, token(令牌))对应哪个username
这样子我们就能解决伪造的问题了

这就是 Session(会话)解决的问题
1. 记住用户状态
2. 解决伪造
3.服务器端 session 怎么实现？

加一个session类,保存sessionID和userID
publicclassSessionextendsBaseModel{
publicStringsessionId;
publicIntegeruserId;

路由到user登录时,routeLogin判断如果用户找到了userid,则新增一个session
Sessionsession=SessionService.add(u.id);
header.put("Set-Cookie",String.format("session_id=%s",session.sessionId));


新的session添加方法如下:SessionService中
Sessionm=newSession();
m.sessionId=UUID.randomUUID().toString();
;
m.userId=userId;

ArrayList<Session>sessionArrayList=load();
sessionArrayList.add(m);

SessionService.save(sessionArrayList);
```





学习md5加密：

```java
package learn;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class digestEample {
    public static void log(String format, Object... args) {
        System.out.println(String.format(format, args));
    }

    public static String hexFromBytes(byte[] array) {
        String hex = new BigInteger(1, array).toString(16);
        int zeroLength = array.length * 2 - hex.length();
        for (int i = 0; i < zeroLength; i++) {
            hex = "0" + hex;
        }
        return hex;
    }

    public static void main(String[] args) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("md5");
        String message = "iiiii3234.99";
        md.update(message.getBytes());

        byte[] result = md.digest();
        log("md5 result %s", result.length);

        String hex = hexFromBytes(result);

        log("md5 result hex (%s) length(%s)", hex, hex.length());

    }
}

```

